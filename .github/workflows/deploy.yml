name: Deploy to EC2

on:
  push:
    branches: [ master ]
  pull_request:
    branches: [ master ]

env:
  CARGO_TERM_COLOR: always
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Install Rust
      uses: dtolnay/rust-toolchain@stable
    
    - name: Install rustfmt
      run: rustup component add rustfmt
          
    - name: Cache dependencies
      uses: actions/cache@v3
      with:
        path: |
          ~/.cargo/bin/
          ~/.cargo/registry/index/
          ~/.cargo/registry/cache/
          ~/.cargo/git/db/
          target/
        key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
        
    - name: Install system dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake build-essential
        
    - name: Run tests
      run: cargo test --verbose
      
    - name: Check code formatting
      run: cargo fmt --all -- --check
      

  build-and-deploy:
    needs: test
    environment: test
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Log in to Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v4
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,prefix={{branch}}-
          
    - name: Build Docker image (solo build local, sin push)
      uses: docker/build-push-action@v4
      with:
        context: .
        push: false
        tags: siscom-consumer:latest
        labels: ${{ steps.meta.outputs.labels }}
    #    - name: Build and push Docker image
    #      uses: docker/build-push-action@v4
    #      with:
    #        context: .
    #        push: true
    #        tags: ${{ steps.meta.outputs.tags }}
    #        labels: ${{ steps.meta.outputs.labels }}
        
    - name: Guardar imagen Docker como tar
      run: docker save -o siscom-consumer.tar siscom-consumer:latest

    - name: Cambiar permisos del archivo tar
      run: chmod 644 siscom-consumer.tar  

    - name: Copiar imagen Docker a EC2
      uses: appleboy/scp-action@v0.1.7
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USERNAME }}
        port: ${{ secrets.EC2_SSH_PORT }}
        key: ${{ secrets.EC2_SSH_KEY }}
        source: "siscom-consumer.tar"
        target: "/tmp/"
        overwrite: true
        debug: true

    - name: Deploy a EC2 usando imagen local
      uses: appleboy/ssh-action@v0.1.7
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USERNAME }}
        port: ${{ secrets.EC2_SSH_PORT }}
        key: ${{ secrets.EC2_SSH_KEY }}
        timeout: 60s
        command_timeout: 10m
        script: |
          # Instalar Docker y Docker Compose si no están presentes
          if ! command -v docker &> /dev/null; then
            echo "Instalando Docker..."
            sudo apt-get update
            sudo apt-get install -y apt-transport-https ca-certificates curl gnupg lsb-release
            curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
            echo \
              "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu \
              $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
            sudo apt-get update
            sudo apt-get install -y docker-ce docker-ce-cli containerd.io
            sudo usermod -aG docker $USER
          fi

          if ! command -v docker-compose &> /dev/null; then
            echo "Instalando Docker Compose..."
            sudo curl -L "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            sudo chmod +x /usr/local/bin/docker-compose
          fi

          sudo systemctl enable docker
          sudo systemctl start docker

          # Cargar la imagen Docker
          docker load -i /tmp/siscom-consumer.tar

          # Stop existing container
          docker stop siscom-consumer || true
          docker rm siscom-consumer || true

          # Create siscom network if it doesn't exist
          docker network create siscom-network 2>/dev/null || true

          # Run new container with environment variables
          docker run -d \
            --name siscom-consumer \
            --restart unless-stopped \
            -v /var/log/siscom-consumer:/var/log/siscom-consumer \
            --network siscom-network \
            -e BROKER_HOST="${{ vars.BROKER_HOST }}" \
            -e BROKER_TOPIC="${{ vars.BROKER_TOPIC }}" \
            -e BROKER_TYPE="${{ vars.BROKER_TYPE }}" \
            -e MQTT_USERNAME="${{ vars.MQTT_USERNAME }}" \
            -e MQTT_PASSWORD="${{ vars.MQTT_PASSWORD }}" \
            -e MQTT_CLIENT_ID="${{ vars.MQTT_CLIENT_ID }}" \
            -e MQTT_KEEP_ALIVE_SECS="${{ vars.MQTT_KEEP_ALIVE_SECS }}" \
            -e MQTT_CLEAN_SESSION="${{ vars.MQTT_CLEAN_SESSION }}" \
            -e MQTT_MAX_RECONNECT_ATTEMPTS="${{ vars.MQTT_MAX_RECONNECT_ATTEMPTS }}" \
            -e KAFKA_ENABLED="${{ vars.KAFKA_ENABLED }}" \
            -e KAFKA_BROKERS="${{ vars.KAFKA_BROKERS }}" \
            -e KAFKA_POSITION_TOPIC="${{ vars.KAFKA_POSITION_TOPIC }}" \
            -e KAFKA_NOTIFICATIONS_TOPIC="${{ vars.KAFKA_NOTIFICATIONS_TOPIC }}" \
            -e KAFKA_BATCH_SIZE="${{ vars.KAFKA_BATCH_SIZE }}" \
            -e KAFKA_BATCH_TIMEOUT_MS="${{ vars.KAFKA_BATCH_TIMEOUT_MS }}" \
            -e KAFKA_COMPRESSION="${{ vars.KAFKA_COMPRESSION }}" \
            -e KAFKA_RETRIES="${{ vars.KAFKA_RETRIES }}" \
            -e DB_HOST="${{ vars.DB_HOST }}" \
            -e DB_PORT="${{ vars.DB_PORT }}" \
            -e DB_DATABASE="${{ vars.DB_DATABASE }}" \
            -e DB_USERNAME="${{ vars.DB_USERNAME }}" \
            -e DB_PASSWORD="${{ secrets.DB_PASSWORD }}" \
            -e DB_MAX_CONNECTIONS="${{ vars.DB_MAX_CONNECTIONS }}" \
            -e DB_MIN_CONNECTIONS="${{ vars.DB_MIN_CONNECTIONS }}" \
            -e DB_CONNECTION_TIMEOUT_SECS="${{ vars.DB_CONNECTION_TIMEOUT_SECS }}" \
            -e DB_IDLE_TIMEOUT_SECS="${{ vars.DB_IDLE_TIMEOUT_SECS }}" \
            -e PROCESSING_WORKER_THREADS="${{ vars.PROCESSING_WORKER_THREADS }}" \
            -e PROCESSING_MESSAGE_BUFFER_SIZE="${{ vars.PROCESSING_MESSAGE_BUFFER_SIZE }}" \
            -e PROCESSING_BATCH_PROCESSING_SIZE="${{ vars.PROCESSING_BATCH_PROCESSING_SIZE }}" \
            -e PROCESSING_MAX_PARALLEL_DEVICES="${{ vars.PROCESSING_MAX_PARALLEL_DEVICES }}" \
            -e RUST_LOG="${{ vars.RUST_LOG }}" \
            -e LOGGING_FILE_PATH="${{ vars.LOGGING_FILE_PATH }}" \
            -e LOGGING_MAX_FILE_SIZE_MB="${{ vars.LOGGING_MAX_FILE_SIZE_MB }}" \
            -e LOGGING_MAX_FILES="${{ vars.LOGGING_MAX_FILES }}" \
            -e LOGGING_JSON_FORMAT="${{ vars.LOGGING_JSON_FORMAT }}" \
            siscom-consumer:latest

          # Wait for container to start
          echo "Esperando que el contenedor inicie..."
          sleep 10

          # Check container status
          CONTAINER_STATUS=$(docker inspect -f '{{.State.Status}}' siscom-consumer)
          echo "Estado del contenedor: $CONTAINER_STATUS"

          if [ "$CONTAINER_STATUS" != "running" ]; then
            echo "❌ ERROR: El contenedor no está en estado 'running'"
            echo "Logs del contenedor:"
            docker logs siscom-consumer --tail 100
            exit 1
          fi

          # Check if container is restarting
          RESTART_COUNT=$(docker inspect -f '{{.RestartCount}}' siscom-consumer)
          echo "Número de reinicios: $RESTART_COUNT"

          if [ "$RESTART_COUNT" -gt "0" ]; then
            echo "⚠️ WARNING: El contenedor se ha reiniciado $RESTART_COUNT veces"
            echo "Logs del contenedor:"
            docker logs siscom-consumer --tail 100
            exit 1
          fi

          # Check for errors in logs
          echo "Verificando logs por errores..."
          if docker logs siscom-consumer 2>&1 | grep -i "error.*database\|failed to\|panic\|fatal"; then
            echo "❌ ERROR: Se encontraron errores en los logs del contenedor"
            echo "Logs completos:"
            docker logs siscom-consumer --tail 100
            exit 1
          fi

          # Show logs if everything is OK
          echo "✅ Contenedor iniciado correctamente"
          docker logs siscom-consumer --tail 50

  cleanup:
    runs-on: ubuntu-latest
    needs: build-and-deploy
    environment: test
    if: always()

    steps:
    - name: Borrar archivo tar en EC2
      uses: appleboy/ssh-action@v0.1.7
      with:
        host: ${{ secrets.EC2_HOST }}
        username: ${{ secrets.EC2_USERNAME }}
        port: ${{ secrets.EC2_SSH_PORT }}
        key: ${{ secrets.EC2_SSH_KEY }}
        script: |
          rm -f /tmp/siscom-consumer.tar